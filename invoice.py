# The COPYRIGHT file at the top level of this repository contains the full
# copyright notices and license terms.
import itertools

from trytond.model import ModelSQL, fields, Unique
from trytond.pool import PoolMeta, Pool
from trytond.pyson import Eval
from trytond.tools import grouped_slice

__all__ = ['Invoice', 'InvoiceMilestoneRelation', 'InvoiceLine']


class Invoice:
    __name__ = 'account.invoice'
    __metaclass__ = PoolMeta

    milestone = fields.One2One('account.invoice-project.invoice_milestone',
        'invoice', 'milestone', 'Milestone', domain=[
            ('project_company', '=', Eval('company', -1)),
            ('project_party', '=', Eval('party', -1)),
            ],
        readonly=True, depends=['company', 'party'])

    @classmethod
    def __setup__(cls):
        super(Invoice, cls).__setup__()
        cls._error_messages.update({
                # 'milestone_amount': ('Amount of invoice "%s" must be '
                #     'equal than its milestone "%s" amount'),
                'reset_invoice_milestone': ('You cannot reset to draft '
                    'an invoice generated by a milestone.'),
                })

    # @classmethod
    # def validate(cls, invoices):
    #     super(Invoice, cls).validate(invoices)
    #     for record in invoices:
    #         record.check_milestone_amount()

    # def check_milestone_amount(self):
    #     if not self.milestone:
    #         return
    #     if (self.milestone.invoice_method == 'amount' append
    #             self.milestone.amount != self.untaxed_amount):
    #         self.raise_user_error('milestone_amount',
    #                             (self.rec_name, self.milestone.rec_name))

    # @fields.depends('milestone')
    # def on_change_with_milestone_group(self):
    #     if self.milestone:
    #         return self.milestone.group.id
    #     return None

    # @classmethod
    # def search_milestone_group(cls, name, clause):
    #     return [('milestone.group',) + tuple(clause[1:])]

    @classmethod
    def credit(cls, invoices, refund=False):
        pool = Pool()
        Milestone = pool.get('project.invoice_milestone')
        WorkInvoicedProgress = pool.get('project.work.invoiced_progress')

        new_invoices = super(Invoice, cls).credit(invoices, refund=refund)

        # TODO: it should go to project_invoice
        inv_line2winvprog = {}
        for winvprog_sub_ids in grouped_slice([l.id
                    for i in invoices for l in i.lines]):
            for winvprog in WorkInvoicedProgress.search([
                        ('invoice_line', 'in', winvprog_sub_ids),
                        ]):
                inv_line2winvprog.setdefault(
                    winvprog.invoice_line.id, []).append(winvprog._credit())

        if inv_line2winvprog:
            winvprog_to_create = []
            for new_inv in new_invoices:
                for new_inv_line in new_inv.lines:
                    for new_winvprog in inv_line2winvprog.get(
                                new_inv_line.origin.id, []):
                        new_winvprog.invoice_line = new_inv_line
                        winvprog_to_create.append(new_winvprog)
            if winvprog_to_create:
                WorkInvoicedProgress.save(winvprog_to_create)
        # END part to move to project_invoice

        milestones_to_create = []
        for invoice, new_invoice in itertools.izip(invoices, new_invoices):
            if invoice.milestone:
                milestones_to_create.append(
                    invoice.milestone._credit(new_invoice))
        if milestones_to_create:
            Milestone.save(milestones_to_create)
            Milestone.confirm(milestones_to_create)
            Milestone.proceed(milestones_to_create)
            milestones_to_succeed = [m for m in milestones_to_create
                if m.invoice.state in ('posted', 'paid')]
            if milestones_to_succeed:
                Milestone.succeed(milestones_to_succeed)

        return new_invoices

    @classmethod
    def draft(cls, invoices):
        pool = Pool()
        Milestone = pool.get('project.invoice_milestone')

        milestone_to_proceed = []
        for invoice in invoices:
            if invoice.state == 'cancel' and invoice.milestone:
                cls.raise_user_error('reset_invoice_milestone')
            elif invoice.state == 'posted' and invoice.milestone:
                milestone_to_proceed.append(invoice.milestone)

        res = super(Invoice, cls).draft(invoices)
        if milestone_to_proceed:
            Milestone.proceed(milestone_to_proceed)
        return res

    @classmethod
    def post(cls, invoices):
        pool = Pool()
        Milestone = pool.get('project.invoice_milestone')
        super(Invoice, cls).post(invoices)
        Milestone.succeed([i.milestone for i in invoices if i.milestone])

    @classmethod
    def cancel(cls, invoices):
        pool = Pool()
        Milestone = pool.get('project.invoice_milestone')
        super(Invoice, cls).cancel(invoices)
        Milestone.fail([i.milestone for i in invoices if i.milestone])

    @classmethod
    def copy(cls, invoices, default=None):
        if default is None:
            default = {}
        else:
            default = default.copy()
        default['milestone'] = None
        return super(Invoice, cls).copy(invoices, default=default)


class InvoiceMilestoneRelation(ModelSQL):
    'Invoice - Project Invoice Milestone'
    __name__ = 'account.invoice-project.invoice_milestone'
    invoice = fields.Many2One('account.invoice', 'Invoice', ondelete='CASCADE',
        required=True, select=True)
    milestone = fields.Many2One('project.invoice_milestone', 'Milestone',
        ondelete='CASCADE', required=True, select=True)

    @classmethod
    def __setup__(cls):
        super(InvoiceMilestoneRelation, cls).__setup__()
        t = cls.__table__()
        cls._sql_constraints += [
            ('invoice_unique', Unique(t, t.invoice),
                'The Invoice must be unique.'),
            ('milestone_unique', Unique(t, t.milestone),
                'The Milestone must be unique.'),
            ]


class InvoiceLine:
    __name__ = 'account.invoice.line'
    __metaclass__ = PoolMeta

    @classmethod
    def _get_origin(cls):
        models = super(InvoiceLine, cls)._get_origin()
        models.append('project.invoice_milestone')
        return models
